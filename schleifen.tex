\RequirePackage{pdfmanagement-testphase}
\DeclareDocumentMetadata{pdfstandard=A-2b}
\documentclass[a5paper,landscape,ngerman,10pt]{article}
\usepackage{babel,listings,geometry,relsize,unicode-math,booktabs}
\usepackage[hidelinks]{hyperref}
\setmainfont{Libertinus Serif}
\setmathfont{Libertinus Math}
%\setmainfont{TeX Gyre Pagella}
%\setmathfont{TeX Gyre Pagella Math}
\lstloadlanguages{[11]C++, Modula-2, Python}
\title{Schleifen wegoptimieren}
\author{Timm Knape\quad(\href{mailto:timm@knp.de}{timm@knp.de})}
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}
\newcounter{aufgc}
\newenvironment{aufg}{\stepcounter{aufgc}\textbf{Aufgabe \theaufgc.}\quad}{}
\begin{document}
\newcommand{\cpp}{C\kern-.1em\raise.30ex\hbox{\smaller{++}}}
\lstset{
  columns=fullflexible,
  language=[11]C++,
  mathescape=true,
  escapechar=\&
}
%
\maketitle
%
\section{Aufgabenstellung}
%
Während meines Informatik-Studiums haben wir die
Programmiersprache \hbox{\textsc{Modula-$2$}} gelernt.
Mühevoll zogen sich die Wochen dahin, in denen wir die
Grundstrukturen verdauten.
Irgendwann wurden Schleifen eingeführt und es kam auf
einem Übungszettel zu folgender Aufgabe:

\begin{quotation}
\textit{Schreibe eine Funktion, welche die 
Summe der ersten $n$ natürlichen Zahlen berechnet.}
\end{quotation}

Erwartet war irgendetwas in der Form

\begin{quotation}
\begin{lstlisting}[language=Modula-2, morekeywords={TO}]
PROCEDURE Sum&\,&($n$: INTEGER): INTEGER;
   VAR $i,s$: INTEGER;
BEGIN
   $s := 0$;
   FOR $i := 1$ TO $n$ DO
      $s := s + 1$;
   END;
   RETURN $s$;
END Sum;
\end{lstlisting}
\end{quotation}

In \cpp\ kann die Funktion etwa so aussehen:

\begin{quotation}
\begin{lstlisting}
int sum&\,&(int $n$) {
   int $s$ {$\,0\,$};
   for (int $i$ {$\,1\,$}; $i$ <= $n$; ++$i$) {
      $s$ += $i$;
   }
   return $i$;
}
\end{lstlisting}
\end{quotation}

Bleiben wir für den Rest dieses Beitrags in dieser Sprache.
Meine Modula-2 Kentnisse sind doch arg eingerostet.

\section{Gaußsche Summenformel}

Ich war natürlich vorwitzig und sah nicht ein,
nur zur Übung eine Schleife zu verwenden,
wenn es nach der Summenformel von Carl~Friedrich~Gauß auch viel eleganter
geht:

\begin{quotation}
\begin{lstlisting}
int sum&\,&(int $n$) {
   return $n * (n + 1) / 2$;
}
\end{lstlisting}
\end{quotation}

In der Schule bekam die Klasse die Aufgabe gestellt, die ersten $100$ Zahlen
(andere Quellen sprechen von $60$) zusammenzuzählen.
Der neunjährige Gauß hatte nach wenigen Sekunden die richtige Lösung im Kopf
berechnet.

Sein Rechenweg funktioniert am besten für gerade $n$.
Statt dessen können wir die ersten $n$ Zahlen zweimal aufschreiben.
Einmal vorwärts und darunter einmal rückwärts:

\begin{quotation}
\begin{tabular}{cccccc}
\toprule
$1$&$2$&$3$&$\mathstrut\cdots$&$n-1$&$n$\\
\midrule
$n$&$n-1$&$n-2$&$\mathstrut\cdots$&$2$&$1$\\
\bottomrule
\end{tabular}
\end{quotation}

Die Tabelle hat $n$ Spalten und die Summe jeder Spalte ist $n+1$.
Die Summe aller Zahlen in der Tabelle beträgt also $n\cdot(n+1)$.
Da die Zahlen aber zweimal aufgeschrieben wurden, muss das
Ergebnis noch durch zwei geteilt werden.

\section{Überlauf}

Ich habe auf diese Aufgabe die vollen Punkte bekommen.
Inzwischen frage ich mich jedoch, ob dies gerechtfertigt war:
Kann es nicht sein, dass durch einen Überlauf falsche Werte
berechnet werden, die in einer Schleife langsam, aber korrekt,
berechnet worden wären?

In vielen Sprachen hat eine Integer-Variable nur eine feste Länge.
Bei meinem System sind das $32$ Bit.
Eine ganze Zahl kann damit nur $2^{32}$ unterschiedliche Werte annehmen.
Das sind die Zahlen $-2^{31}$ bis $2^{31}-1$, da der Datentyp \lstinline|int|
auch negative Zahlen unterstützt
(genauso wie der Datentyp \lstinline[language=Modula-2]|INTEGER|
in \textsc{Modula-$2$}).

Auch die Schleife liefert nicht für jedes mögliche $n$ die richtige Lösung.
Irgendwann wird die Summe größer oder gleich $2^{31}$ und es entsteht ein
Überlauf.
Das Ergebnis ist gültig, so lange es klein genug ist:

\[2^{31} > \frac{n\cdot(n + 1)}2\hbox{.}\]

Hier nutze ich die Gauß-Formel für die Abschätzung der
Schleifen-Implementierung.
Denn nun befinden wir uns in der reinen Mathematik, in der es keine
Überläufe gibt.

Durch Multiplizieren mit $2$ ergibt sich

\[2^{32} > n\cdot(n+1)\hbox{.}\]

Die Ungleichung bleibt bestehen, wenn das $n+1$ durch $n$
ersetzt wird. Dadurch wird die rechte Seite nur noch kleiner:

\[2^{32} > n^2\hbox{.}\]

Und durch Ziehen der Quadrat-Wurzel ergibt sich

\[2^{16} > n\hbox{.}\]

Diese Grenze ist scharf! Schon mit $n=2^{16}$ läßt sich
$n\cdot(n+1)$ nicht mehr mit $32$ Bit darstellen.
Somit können wir auch mit der Schleife nur bis zur Zahl $65.535$
aufsummieren, die gerade noch mit $16$ Bit dargestellt werden kann.
Bei größeren Zahlen gibt es einen Überlauf und ein falsches Ergebnis.

Bei der oben angegebenen Umsetzung der Gauß-Methode tritt der
Überlauf schon viel früher ein.
Schon wenn $n$ mit $n+1$ multipliziert wird, ist das Ergebnis nur gültig,
wenn

\[2^{31}>n\cdot(n+1)\]

gilt.
Durch die gleiche Abschätzung wie oben ergibt sich

\[2^{31}>n^2\]

und wieder durch die Anwendung der Quadrat-Wurzel resultiert

\[\sqrt{2}\cdot2^{15}>46.340\geq n\hbox{.}\]

Schon mit $n=46.341$ passt das Ergebnis nicht mehr in $31$ Bit und liefert
ein negatives Ergebnis.
Für alle Zahlen von $46.341$ bis $65.535$ erhalten wir mit dem
Gauß-Algorithmus keine korrekte Lösung.
Die Schleife kann für über $40\,\%$ mehr Werte das richtige Ergebnis
berechnen!

\section{Gauß ohne Überlauf}

Der Überlauf kann verhindert werden, wenn wir entweder $n$ oder
$n+1$ erst durch $2$ teilen und dann mit dem anderen Faktor
multiplizieren.
Jedoch dürfen wir nur die Zahl durch $2$ teilen, die gerade
ist.
Andernfalls entstehen Rundungsfehler.

Das kann durch eine Fallunterscheidung erreicht werden:

\begin{quotation}
\begin{lstlisting}
int sum&\,&(int $n$) {
   if ($n\mathrel\% 2$) {
      return $(n + 1)/2\:*\:n$;
   } else {
      return $n/2 \:*\: (n + 1)$;
   }
}
\end{lstlisting}
\end{quotation}

Damit funktioniert Gauß wieder bis zur Grenze $65.535$.
Und erst damit ist die Aufgabe eigentlich gelöst.

Der Compiler wird hoffentlich die Modulo-Operation durch eine
Und-Verknüpfung und die Division durch eine
Verschiebe-Operation ersetzen, die auf den meisten
Prozessoren deutlich schneller sind.

Wenn wir dem Compiler nicht trauen, können wir auch direkt
auf Bit-Ebene die Anweisungen geben:

\begin{quotation}
\begin{lstlisting}
int sum&\,&(int $n$) {
   if ($n \mathrel\& 1$) {
      return $((n + 1) >\!> 1) * n$;
   } else {
      return $(n >\!> 1) * (n + 1)$;
   }
}
\end{lstlisting}
\end{quotation}

Aber es geht \textit{noch\/} besser.
Die Fallunterscheidung macht bei aktuellen Prozessor-Pipelines
Probleme.
Wenn der Prozessor den falschen Weg rät, muss die
Pipeline neu angekurbelt werden.
Besser und effizienter sind Lösungen, die keine
Sprünge benötigen.
Und die gibt es.

Hier möchte ich eine Low-Level Variante vorstellen.
Wir wissen, dass $n$ nicht größer als $65.535$ werden
kann.
Dieses $n$ passt aber noch in $16$ Bit.
Dann passt das Produkt von $n$ und $n+1$ aber noch in
$32$ Bit.
Nicht in $31$ Bit, aber in $32$!
Somit klappt alles, wenn wir mit Zahlen rechnen, die
keinen negativen Wertebereich haben.
Hier der Vorschlag:

\begin{quotation}
\begin{lstlisting}
inline int sum&\,&(int $n$) {
   auto $\mathit{un}$ {&\,&static_cast<unsigned>&\,&($n$)$\,$};
   return static_cast<int>&\,&(
      $(\mathit{un} * (\mathit{un} + 1)) >\!> 1$
   );
}
\end{lstlisting}
\end{quotation}

Der Wechsel nach \lstinline!unsigned! ist notwendig, damit
bei der Verschiebung immer $0$-Bits nachgezogen werden.
Bei \lstinline!int! bleibt das oberste Bit unberücksichtigt
(und dadurch bleibt die Zahl negativ).

Sieht gewaltig aus (mit dem \lstinline!static_cast!), aber
der generierte Code ist sehr effizient.
Es müssen nur andere Maschinenbefehle verwendet werden.

\section{Andere Programmiersprachen}

Viele andere Sprachen haben das gleiche Problem:

\begin{quotation}
 Java,\qquad C\#,\qquad Rust,\qquad Go.
\end{quotation}

Es gibt aber Sprachen, die intern mit beliebig großen
Zahlen rechnen können:

\begin{quotation}
 Scheme/Lisp,\qquad Python, \qquad Ruby.
\end{quotation}

Unter Python können wir einfach die Standard-Version
des Gauß-Algorithmus verwenden:

\begin{quotation}
\begin{lstlisting}[language=Python]
def sum&\,&($n$):
   return $n * (n + 1) \mathrel{/\!/} 2$
\end{lstlisting}
\end{quotation}

Jedoch ist der Umgang mit beliebig großen ganze Zahlen
ein erheblicher Mehraufwand für den Rechner.
Anstatt direkt in eimen Register zu rechnen, müssen die
Zahlen über mehrere Worte des Arbeitsspeichers verteilt
oder in mehreren Registern abgelegt werden.
Dabei entstehen zwangsweise Sprünge, da von vorne herein
nicht klar ist, wie viel Speicher die Zahl belegt.

\section{Zusammenfassung}

Selbst bei so einer einfachen Schleifen-Optimierung ist
Vorsicht angesagt.
Die enorme Kosteneinsparung kann ggf.\ eine Einschränkung
des Anwendungsbereichs zur Folge haben.
Wenn wir dies nicht beachten, produziert der verbesserte
Code schwer zu findende Fehler.
Mit etwas Nachdenken finden sich aber häufig verbesserte
Lösungen.

Nicht jeder Code muss bis zu seinem Maximum optimiert
werden.
Schon die Beschreibung des Maximums ist nicht leicht.
Soll der Code möglichst schnell laufen?
Oder möglichst klein sein?
Beides schließt sich oft aus.
Schön ist, wenn wie in diesem Beispiel eine kleine,
schnelle Lösung existiert.

Leider rentiert es sich oft nicht, eine solche Lösung
zu suchen.
Die Rechner sind schnell genug, dass auch suboptimale
Lösungen verwendet werden können.
Diese verbrauchen jedoch mehr Energie, Speicher und
Rechenzeit als eine bessere Lösung, über die wir ein
klein wenig mehr nachgedacht hat.

\section{Weiter denken}

\begin{aufg}
JavaScript verwendet nur $64$-Bit Floating-Point Zahlen.
Wie weit kann die Schleifen-Variante korrekte Ergebnisse
liefern? Wie weit der einfache Gauß?
\end{aufg}

\begin{aufg}
Wie verhalten sich Systeme, auf denen $64$-Bit Integer-Zahlen
verwendet werden?
\end{aufg}

\begin{aufg}
Wie verhalten sich Systeme, die direkt mit
\lstinline!unsigned! Zahlen rechnen?
Warum kann die Shift-Variante dort nicht verwendet werden?
\end{aufg}

\begin{aufg}
Ein ähnliches Problem tritt beim Berechnen eines Mittelwerts
auf:

\[\left\lfloor\frac{a+b}2\right\rfloor\]

Formuliere eine ggf.\ ineffiziente Scheife, die Überläufe verhindert.
\end{aufg}

\begin{aufg}
Kann beim Mittelwert auch eine Shift-Variante entwickelt werden, welche
das zusätzliche Vorzeichen-Bit ausnutzt?
\end{aufg}
\end{document}
